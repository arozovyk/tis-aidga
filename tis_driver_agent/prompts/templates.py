"""Prompt templates for driver generation."""

from pathlib import Path
from typing import List, Dict

# Path to tis_builtin.h relative to this file
TIS_BUILTIN_PATH = Path(__file__).parent.parent / "stubs" / "tis_builtin.h"


def get_tis_builtin_header() -> str:
    """Read tis_builtin.h from disk.

    Note: The content is escaped for use with str.format() - all { and } are doubled
    to prevent them being interpreted as format placeholders.
    """
    if TIS_BUILTIN_PATH.exists():
        content = TIS_BUILTIN_PATH.read_text()
        # Escape curly braces for str.format() compatibility
        return content.replace("{", "{{").replace("}", "}}")
    return "// tis_builtin.h not found"


DRIVER_GENERATION_TEMPLATE = """
You are an expert C programmer specializing in writing verification drivers for formal analysis using TrustInSoft Analyzer.

## Context

Function to test: {function_name}

### Include Paths:
{include_paths}

### Source Files:
{context}

{skeleton_section}

## Requirements

Write a C11 verification driver for {function_name}.

The goal is to mathematically verify the absence of undefined behaviors (UB) through abstract interpretation.
TrustInSoft Analyzer executes the code symbolically: given fully-defined C code, if no alarms are raised,
the code is guaranteed to behave predictably regardless of compiler or target platform.
By providing generalized inputs, you help verify that all possible execution paths within those ranges are UB-free.

### Driver Structure:
1. Header comment: `// TIS-Analyzer verification driver for function {function_name}. It has been generated by tischiron with model {model}.`
2. Include `<tis_builtin.h>`
3. Function declaration as `extern`
4. Driver function: `__tis_{function_name}_driver(void)`
5. Main function calling all driver functions in order

### TIS Builtin Functions:

A "generalized" value means a random value within a specified range. For example, a generalized value between 0 and 10 represents any random value in the range [0, 10].

Here is the full `tis_builtin.h` header with all available functions:

```c
{tis_builtin_header}
```

### Object Creation:
- You can create objects on the stack, with `tis_alloc()`, or using constructor functions from the API
- If constructor functions are provided in the context (e.g., `foo_new()`, `foo_create()`), prefer using them. Declare them as `extern` in your driver
- When using constructors, use opaque forward declarations (`struct foo;`) instead of defining struct contents

### Stubs:
A stub is a simplified reimplementation of a function that produces sufficiently accurate behavior for analysis without the full implementation complexity.

When to create stubs:
- External dependencies (filesystem, network, hardware registers) that aren't available during analysis
- Functions with side effects that would complicate analysis (e.g., logging, I/O)
- Third-party library functions not included in the analysis scope

Stub guidelines:
- Return generalized values covering the expected output range: `int stub_read() {{ return tis_interval(-1, MAX_READ); }}`
- For functions that modify output parameters, use `tis_make_unknown()` to fill buffers with abstract values
- Preserve the function's contract: if the real function can return errors, the stub should too
- Declare stubs as regular functions (not `extern`) so they override the original during linking

### Using Generalized Values:

**IMPORTANT:** When passing numeric arguments to functions, use the appropriate interval function instead of hardcoded values. This ensures the analyzer tests all possible values in a range.

Examples:
- Instead of `create_int(42)`, use `create_int(tis_interval(-1000, 1000))`
- Instead of `create_double(3.14)`, use `create_double(tis_double_interval(-1e6, 1e6))`
- Instead of `set_value(100)`, use `set_value(tis_interval(0, INT32_MAX))`
- For booleans: use `tis_interval(0, 1)` or `tis_nondet(0, 1)`

**Over-approximation warning:** When intervals are too wide, the analyzer may need to merge states, causing over-approximation. This can lead to:
- False alarms on unrealistic code paths (e.g., error handlers triggered by impossible values)
- State explosion slowing analysis or exhausting memory
- Imprecise results that are hard to interpret

Mitigation strategies:
- Use domain-appropriate ranges (e.g., for a percentage: `tis_interval(0, 100)`, not `tis_interval(INT32_MIN, INT32_MAX)`)
- Constrain inputs based on function preconditions or API contracts
- For complex algorithms (parsers, crypto), consider narrower ranges or multiple targeted drivers

### Rules:
- Test NULL pointers using `tis_nondet_ptr(valid_ptr, NULL)` unless documented otherwise
- Array lengths should use #define macros instead of tis_interval for sizes
- All strings must be null-terminated
- Focus on exercising code paths rather than testing function effects
- Initialize all struct fields before use
- Use "generalized" instead of "random" in comments

### Header Includes:
- Include `<tis_builtin.h>` and standard C headers as needed (`<stddef.h>`, `<stdint.h>`, `<string.h>`, etc.)
- You may include project headers if they are provided in the context
- Alternatively, use forward declarations for types you don't need to access internals of

### Output Format:
Return ONLY C11 code in a ```c block. No explanations outside code comments.
"""

REFINER_TEMPLATE = """
You are fixing a TIS-Analyzer verification driver that failed compilation.

## Current Driver Code:
```c
{current_code}
```

## Compilation Errors:
{errors}

## Common Fixes:
- "incomplete type": Provide full struct definition with all fields, not just forward declaration
- "undeclared identifier": Add missing forward declaration (do NOT add project header includes)
- "variable-sized object": Use #define macros for array sizes
- "unbound function tis_*": Include <tis_builtin.h>
- "Incompatible declaration" / "not isomorphic": Your type definitions conflict with the actual source. Use opaque pointers (`struct X;`) instead of redefining structs, or ensure your definitions exactly match the source

## CRITICAL Rules:
- NEVER add project-specific headers (e.g., `<json-c/json.h>`, `"myproject.h"`)
- ONLY use `<tis_builtin.h>` and standard C headers
- Use forward declarations (`struct X;`) for types you don't need to access internals of
- The driver is compiled with the actual source files, so forward declarations are sufficient

## Instructions:
Fix the compilation errors while maintaining the driver's purpose.
Return the complete corrected driver in a ```c block.

Iteration: {iteration}/{max_iterations}
"""


def format_context_from_contents(context_contents: List[Dict[str, str]]) -> str:
    """
    Format context files for prompt injection.

    Args:
        context_contents: List of dicts with 'name' and 'content' keys

    Returns:
        Formatted string with all context files
    """
    formatted = []
    for ctx in context_contents:
        name = ctx.get("name", "unknown")
        content = ctx.get("content", "")
        formatted.append(f"File: {name}\n```c\n{content}\n```")

    return "\n\n".join(formatted)


def format_include_paths(include_paths: List[str]) -> str:
    """Format include paths for prompt."""
    if not include_paths:
        return "(none specified)"
    return "\n".join(f"- {path}" for path in include_paths)


def build_generation_prompt(
    function_name: str,
    context_contents: List[Dict[str, str]],
    include_paths: List[str] = None,
    model: str = "unknown",
    skeleton_code: str = None,
) -> str:
    """
    Build the driver generation prompt.

    Args:
        function_name: Name of the function to generate driver for
        context_contents: List of dicts with 'name' and 'content' keys
        include_paths: List of include paths from compilation database
        model: Model name used to generate the driver
        skeleton_code: Optional skeleton generated by tis-analyzer -drivergen-skeleton
                       (currently disabled - reserved for future use)

    Returns:
        Formatted prompt string
    """
    # skeleton_code is currently disabled but kept for API compatibility
    del skeleton_code  # Unused - see NOTE below
    context = format_context_from_contents(context_contents)
    includes = format_include_paths(include_paths or [])

    # Add skeleton section if available
    # NOTE: Skeleton is currently disabled - it provides full struct definitions
    # which causes LLM to use tis_alloc() instead of factory functions
    skeleton_section = ""
    # if skeleton_code:
    #     skeleton_section = f"""### Driver Skeleton:
    #
    # The following skeleton has been automatically generated using `tis-analyzer -drivergen-skeleton {function_name}`.
    # It contains all necessary type definitions and forward declarations.
    #
    # **CRITICAL**:
    # - Use this skeleton as the basis for your driver
    # - The skeleton provides all necessary forward declarations - do NOT add project header includes
    # - Fill in the body of the `__tis_{function_name}_driver(void)` function with parameter initialization and function calls
    # - Do not redefine types that are already forward-declared in the skeleton
    #
    # ```c
    # {skeleton_code}
    # ```
    # """

    return DRIVER_GENERATION_TEMPLATE.format(
        function_name=function_name,
        context=context,
        include_paths=includes,
        model=model,
        skeleton_section=skeleton_section,
        tis_builtin_header=get_tis_builtin_header(),
    )


def build_refiner_prompt(
    current_code: str, errors: list, iteration: int, max_iterations: int
) -> str:
    """Build the refinement prompt."""
    if errors:
        error_text = "\n".join(errors)
    else:
        error_text = (
            "Compilation failed but no specific error messages were captured. "
            "Common issues to check:\n"
            "- Incompatible type declarations between driver and source\n"
            "- Missing or incorrect struct definitions\n"
            "- Function signature mismatches\n"
            "- Missing #include directives"
        )
    return REFINER_TEMPLATE.format(
        current_code=current_code,
        errors=error_text,
        iteration=iteration,
        max_iterations=max_iterations,
    )


# TODO make a switch on a arbitrary tis_interval 0-10000,
# for each case of the switch exectute signle unit test (make a template). This allows "sandboxing" by branch.


#TODO rm tis_init_type
