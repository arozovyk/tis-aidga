"""Prompt templates for driver generation."""

from typing import List, Dict

# Condensed TIS builtin reference for prompts (no ACSL, no C++ macros, no URLs)
TIS_BUILTIN_REFERENCE = """
// Core interval functions - create generalized values in range [min, max]
int tis_interval(int min, int max);                    // alias: tis_int_interval
int tis_int_interval(int min, int max);
unsigned int tis_unsigned_int_interval(unsigned int min, unsigned int max);
long tis_long_interval(long min, long max);
unsigned long tis_unsigned_long_interval(unsigned long min, unsigned long max);
long long tis_long_long_interval(long long min, long long max);
unsigned long long tis_unsigned_long_long_interval(unsigned long long min, unsigned long long max);
short tis_short_interval(short min, short max);
unsigned short tis_unsigned_short_interval(unsigned short min, unsigned short max);
char tis_char_interval(char min, char max);
unsigned char tis_unsigned_char_interval(unsigned char min, unsigned char max);
float tis_float_interval(float min, float max);
double tis_double_interval(double min, double max);

// Fill memory with abstract/unknown values
void tis_make_unknown(char *p, unsigned long len);

// Nondeterministic choice between two values
int tis_nondet(int a, int b);

// Nondeterministic choice between two pointers (useful for NULL testing)
static inline void *tis_nondet_ptr(void *a, void *b);
"""


def get_tis_builtin_reference() -> str:
    """Return condensed TIS builtin reference for prompts."""
    return TIS_BUILTIN_REFERENCE


DRIVER_GENERATION_TEMPLATE = """
You are an expert C programmer specializing in writing verification drivers for formal analysis using TrustInSoft Analyzer.

## Context

Function to test: {function_name}

### Source Files:
{context}

{skeleton_section}

## Requirements

Write a comprehensive C11 verification driver for {function_name}. Cover all relevant edge cases and code paths. Go beyond minimal implementations while keeping the driver focused and minimal—do not add unnecessary abstractions, helper functions, or features beyond what's needed to verify the target function.

The goal is to mathematically verify the absence of undefined behaviors (UB) through abstract interpretation.
TrustInSoft Analyzer executes the code symbolically: given fully-defined C code, if no alarms are raised,
the code is guaranteed to behave predictably regardless of compiler or target platform.
By providing generalized inputs, you help verify that all possible execution paths within those ranges are UB-free.

### Driver Structure:
1. Header comment: `// TIS-Analyzer verification driver for function {function_name}. It has been generated by tischiron with model {model}.`
2. Include `<tis_builtin.h>`
3. Function declaration as `extern`
4. Driver function: `__tis_{function_name}_driver(void)`
5. Main function calling all driver functions in order

### TIS Builtin Functions:

A "generalized" value means a value within a specified range that represents all possible values in that range during analysis. For example, `tis_interval(0, 10)` represents any value in [0, 10].

Available functions from `<tis_builtin.h>`:
```c
{tis_builtin_reference}
```

### Object Creation:
- You can create objects on the stack, with `tis_alloc()`, or using constructor functions from the API
- If constructor functions are provided in the context (e.g., `foo_new()`, `foo_create()`), prefer using them. Declare them as `extern` in your driver
- When using constructors, use opaque forward declarations (`struct foo;`) instead of defining struct contents

### Stubs:
A stub is a simplified reimplementation of a function that produces sufficiently accurate behavior for analysis without the full implementation complexity.

When to create stubs:
- External dependencies (filesystem, network, hardware registers) that aren't available during analysis
- Functions with side effects that would complicate analysis (e.g., logging, I/O)
- Third-party library functions not included in the analysis scope

Stub guidelines:
- Return generalized values covering the expected output range: `int stub_read() {{ return tis_interval(-1, MAX_READ); }}`
- For functions that modify output parameters, use `tis_make_unknown()` to fill buffers with abstract values
- Preserve the function's contract: if the real function can return errors, the stub should too
- Declare stubs as regular functions (not `extern`) so they override the original during linking

### Using Generalized Values:

When passing numeric arguments to functions, use the appropriate interval function instead of hardcoded values. This ensures the analyzer tests all possible values in a range.

Examples:
- Instead of `create_int(42)`, use `create_int(tis_interval(-1000, 1000))`
- Instead of `create_double(3.14)`, use `create_double(tis_double_interval(-1e6, 1e6))`
- Instead of `set_value(100)`, use `set_value(tis_interval(0, INT32_MAX))`
- For booleans: use `tis_interval(0, 1)` or `tis_nondet(0, 1)`

Over-approximation warning: When intervals are too wide, the analyzer may need to merge states, causing over-approximation. This can lead to:
- False alarms on unrealistic code paths (e.g., error handlers triggered by impossible values)
- State explosion slowing analysis or exhausting memory
- Imprecise results that are hard to interpret

Mitigation strategies:
- Use domain-appropriate ranges (e.g., for a percentage: `tis_interval(0, 100)`, not `tis_interval(INT32_MIN, INT32_MAX)`)
- Constrain inputs based on function preconditions or API contracts
- For complex algorithms (parsers, crypto), consider narrower ranges or multiple targeted drivers

### Guidelines:

Test NULL pointers using `tis_nondet_ptr(valid_ptr, NULL)` unless documentation indicates the pointer must be valid. Array lengths should use `#define` macros instead of `tis_interval` for sizes, as variable-length arrays complicate analysis. Ensure all strings are null-terminated and all struct fields are initialized before use.

Focus on exercising code paths rather than testing function effects—the goal is to reach all branches, not to verify return values. Use "generalized" instead of "random" in comments because "generalized" accurately describes abstract interpretation semantics, while "random" implies probabilistic testing.

### Header Includes:
- Include `<tis_builtin.h>` and standard C headers as needed (`<stddef.h>`, `<stdint.h>`, `<string.h>`, etc.)
- You may include project headers if they are provided in the context
- Alternatively, use forward declarations for types you don't need to access internals of

### Output Format:
Return your driver in a single ```c code block. If you need to explain critical decisions, use C comments within the code.
"""

REFINER_TEMPLATE = """
You are fixing a TIS-Analyzer verification driver that failed compilation.

## Current Driver Code:
```c
{current_code}
```

## Compilation Errors:
{errors}

## Common Fixes:
- "incomplete type": Provide full struct definition with all fields, not just forward declaration
- "undeclared identifier": Add missing forward declaration (do NOT add project header includes)
- "variable-sized object": Use #define macros for array sizes
- "unbound function tis_*": Include <tis_builtin.h>
- "Incompatible declaration" / "not isomorphic": Your type definitions conflict with the actual source. Use opaque pointers (`struct X;`) instead of redefining structs, or ensure your definitions exactly match the source

## Header Rules:
Use only `<tis_builtin.h>` and standard C headers. For project types, use forward declarations (`struct X;`) rather than including project headers like `<json-c/json.h>` or `"myproject.h"`. The driver is compiled with the actual source files, so forward declarations are sufficient.

## Instructions:
Fix the compilation errors while maintaining the driver's purpose.
Return the complete corrected driver in a ```c block.

Iteration: {iteration}/{max_iterations}
"""


def format_context_from_contents(context_contents: List[Dict[str, str]]) -> str:
    """
    Format context files for prompt injection.

    Args:
        context_contents: List of dicts with 'name' and 'content' keys

    Returns:
        Formatted string with all context files
    """
    formatted = []
    for ctx in context_contents:
        name = ctx.get("name", "unknown")
        content = ctx.get("content", "")
        formatted.append(f"File: {name}\n```c\n{content}\n```")

    return "\n\n".join(formatted)


def format_include_paths(include_paths: List[str]) -> str:
    """Format include paths for prompt."""
    if not include_paths:
        return "(none specified)"
    return "\n".join(f"- {path}" for path in include_paths)


def build_generation_prompt(
    function_name: str,
    context_contents: List[Dict[str, str]],
    include_paths: List[str] = None,
    model: str = "unknown",
    skeleton_code: str = None,
) -> str:
    """
    Build the driver generation prompt.

    Args:
        function_name: Name of the function to generate driver for
        context_contents: List of dicts with 'name' and 'content' keys
        include_paths: List of include paths from compilation database
        model: Model name used to generate the driver
        skeleton_code: Optional skeleton generated by tis-analyzer -drivergen-skeleton
                       (currently disabled - reserved for future use)

    Returns:
        Formatted prompt string
    """
    # skeleton_code is currently disabled but kept for API compatibility
    del skeleton_code  # Unused - see NOTE below
    context = format_context_from_contents(context_contents)
    includes = format_include_paths(include_paths or [])

    # Add skeleton section if available
    # NOTE: Skeleton is currently disabled - it provides full struct definitions
    # which causes LLM to use tis_alloc() instead of factory functions
    skeleton_section = ""
    # if skeleton_code:
    #     skeleton_section = f"""### Driver Skeleton:
    #
    # The following skeleton has been automatically generated using `tis-analyzer -drivergen-skeleton {function_name}`.
    # It contains all necessary type definitions and forward declarations.
    #
    # **CRITICAL**:
    # - Use this skeleton as the basis for your driver
    # - The skeleton provides all necessary forward declarations - do NOT add project header includes
    # - Fill in the body of the `__tis_{function_name}_driver(void)` function with parameter initialization and function calls
    # - Do not redefine types that are already forward-declared in the skeleton
    #
    # ```c
    # {skeleton_code}
    # ```
    # """

    return DRIVER_GENERATION_TEMPLATE.format(
        function_name=function_name,
        context=context,
        model=model,
        skeleton_section=skeleton_section,
        tis_builtin_reference=get_tis_builtin_reference(),
    )


def build_refiner_prompt(
    current_code: str, errors: list, iteration: int, max_iterations: int
) -> str:
    """Build the refinement prompt."""
    if errors:
        error_text = "\n".join(errors)
    else:
        error_text = (
            "Compilation failed but no specific error messages were captured. "
            "Common issues to check:\n"
            "- Incompatible type declarations between driver and source\n"
            "- Missing or incorrect struct definitions\n"
            "- Function signature mismatches\n"
            "- Missing #include directives"
        )
    return REFINER_TEMPLATE.format(
        current_code=current_code,
        errors=error_text,
        iteration=iteration,
        max_iterations=max_iterations,
    )


# TODO make a switch on a arbitrary tis_interval 0-10000,
# for each case of the switch exectute signle unit test (make a template). This allows "sandboxing" by branch.


#TODO rm tis_init_type
