"""Prompt templates for driver generation."""

from typing import List, Dict

DRIVER_GENERATION_TEMPLATE = """
You are an expert C programmer specializing in TrustInSoft Analyzer verification drivers.

## Context

Function to test: {function_name}

### Include Paths:
{include_paths}

### Source Files:
{context}

{skeleton_section}

## Requirements

Write a strictly conformant C11 verification driver for {function_name}.
The goal is to detect coding errors that may lead to undefined behaviors.

### Driver Structure:
1. Header comment: `// TIS-Analyzer verification driver for function {function_name}. It has been generated by tis-ai with model {model}.`
2. Include `<tis_builtin.h>`
3. All required type definitions (complete, not just declarations)
4. Function declaration as `extern`
5. Driver function: `__tis_{function_name}_driver(void)`
6. Main function calling all test functions in order

### TIS Builtin Functions (use ONLY these):
- `void tis_make_unknown(char *addr, unsigned long len)` - Initialize memory with generalized values
- `int tis_interval(int min, int max)` - Generalized integer in range [min, max]
- `void *tis_alloc(size_t size)` - Allocate raw memory ONLY for primitive types/arrays (NOT for complex structs with constructors)
- `void *tis_nondet_ptr(void *p1, void *p2)` - Return either p1 or p2

### Object Creation Rules:
- **If constructor functions are provided in the context (e.g., `foo_new()`, `foo_create()`)**: USE THEM to create objects. Declare them as `extern` in your driver.
- **If NO constructor is provided**: Use `tis_alloc()` with manual field initialization
- **NEVER manually define struct contents when constructors are available** - use opaque forward declarations (`struct foo;`)

### Rules:
- Test NULL pointers using `tis_nondet_ptr(valid_ptr, NULL)` unless documented otherwise
- Array lengths MUST use #define macros, never tis_interval for sizes
- All strings MUST be null-terminated
- Never test function effects, only exercise code paths
- Do not insert code that is not useful to call {function_name}
- Initialize all struct fields before use
- Use "generalized" not "random" in comments
- In the comment, describe why a line is here, but do not comment on things that are not here

### CRITICAL - Header Includes:
- ONLY include `<tis_builtin.h>` and standard C headers (`<stddef.h>`, `<stdint.h>`, `<string.h>`, etc.)
- NEVER include project-specific headers (e.g., `<json-c/json.h>`, `"myproject.h"`)
- All project types MUST be forward-declared in the driver using the skeleton's declarations
- The driver will be compiled alongside the actual source files, so forward declarations are sufficient

### Output Format:
Return ONLY valid C11 code in a ```c block. No explanations outside code comments.
Do not give your thought process. Write only code in your answer.
"""

REFINER_TEMPLATE = """
You are fixing a TIS-Analyzer verification driver that failed compilation.

## Current Driver Code:
```c
{current_code}
```

## Compilation Errors:
{errors}

## Common Fixes:
- "incomplete type": Provide full struct definition with all fields, not just forward declaration
- "undeclared identifier": Add missing forward declaration (do NOT add project header includes)
- "variable-sized object": Use #define macros for array sizes
- "unbound function tis_*": Include <tis_builtin.h>
- "Incompatible declaration" / "not isomorphic": Your type definitions conflict with the actual source. Use opaque pointers (`struct X;`) instead of redefining structs, or ensure your definitions exactly match the source

## CRITICAL Rules:
- NEVER add project-specific headers (e.g., `<json-c/json.h>`, `"myproject.h"`)
- ONLY use `<tis_builtin.h>` and standard C headers
- Use forward declarations (`struct X;`) for types you don't need to access internals of
- The driver is compiled with the actual source files, so forward declarations are sufficient

## Instructions:
Fix the compilation errors while maintaining the driver's purpose.
Return the complete corrected driver in a ```c block.

Iteration: {iteration}/{max_iterations}
"""


def format_context_from_contents(context_contents: List[Dict[str, str]]) -> str:
    """
    Format context files for prompt injection.

    Args:
        context_contents: List of dicts with 'name' and 'content' keys

    Returns:
        Formatted string with all context files
    """
    formatted = []
    for ctx in context_contents:
        name = ctx.get("name", "unknown")
        content = ctx.get("content", "")
        formatted.append(f"File: {name}\n```c\n{content}\n```")

    return "\n\n".join(formatted)


def format_include_paths(include_paths: List[str]) -> str:
    """Format include paths for prompt."""
    if not include_paths:
        return "(none specified)"
    return "\n".join(f"- {path}" for path in include_paths)


def build_generation_prompt(
    function_name: str,
    context_contents: List[Dict[str, str]],
    include_paths: List[str] = None,
    model: str = "unknown",
    skeleton_code: str = None,
) -> str:
    """
    Build the driver generation prompt.

    Args:
        function_name: Name of the function to generate driver for
        context_contents: List of dicts with 'name' and 'content' keys
        include_paths: List of include paths from compilation database
        model: Model name used to generate the driver
        skeleton_code: Optional skeleton generated by tis-analyzer -drivergen-skeleton

    Returns:
        Formatted prompt string
    """
    context = format_context_from_contents(context_contents)
    includes = format_include_paths(include_paths or [])

    # Add skeleton section if available
    # NOTE: Skeleton is currently disabled - it provides full struct definitions
    # which causes LLM to use tis_alloc() instead of factory functions
    skeleton_section = ""
    # if skeleton_code:
    #     skeleton_section = f"""### Driver Skeleton:
    #
    # The following skeleton has been automatically generated using `tis-analyzer -drivergen-skeleton {function_name}`.
    # It contains all necessary type definitions and forward declarations.
    #
    # **CRITICAL**:
    # - Use this skeleton as the basis for your driver
    # - The skeleton provides all necessary forward declarations - do NOT add project header includes
    # - Fill in the body of the `__tis_{function_name}_driver(void)` function with parameter initialization and function calls
    # - Do not redefine types that are already forward-declared in the skeleton
    #
    # ```c
    # {skeleton_code}
    # ```
    # """

    return DRIVER_GENERATION_TEMPLATE.format(
        function_name=function_name,
        context=context,
        include_paths=includes,
        model=model,
        skeleton_section=skeleton_section,
    )


def build_refiner_prompt(
    current_code: str, errors: list, iteration: int, max_iterations: int
) -> str:
    """Build the refinement prompt."""
    if errors:
        error_text = "\n".join(errors)
    else:
        error_text = (
            "Compilation failed but no specific error messages were captured. "
            "Common issues to check:\n"
            "- Incompatible type declarations between driver and source\n"
            "- Missing or incorrect struct definitions\n"
            "- Function signature mismatches\n"
            "- Missing #include directives"
        )
    return REFINER_TEMPLATE.format(
        current_code=current_code,
        errors=error_text,
        iteration=iteration,
        max_iterations=max_iterations,
    )
