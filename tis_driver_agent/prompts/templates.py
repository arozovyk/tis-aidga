"""Prompt templates for driver generation."""

from typing import List, Dict

# Condensed TIS builtin reference for prompts (no ACSL, no C++ macros, no URLs)
TIS_BUILTIN_REFERENCE = """
// Core interval functions - create generalized values in range [min, max]
int tis_interval(int min, int max);                    // alias: tis_int_interval
int tis_int_interval(int min, int max);
unsigned int tis_unsigned_int_interval(unsigned int min, unsigned int max);
long tis_long_interval(long min, long max);
unsigned long tis_unsigned_long_interval(unsigned long min, unsigned long max);
long long tis_long_long_interval(long long min, long long max);
unsigned long long tis_unsigned_long_long_interval(unsigned long long min, unsigned long long max);
short tis_short_interval(short min, short max);
unsigned short tis_unsigned_short_interval(unsigned short min, unsigned short max);
char tis_char_interval(char min, char max);
unsigned char tis_unsigned_char_interval(unsigned char min, unsigned char max);
float tis_float_interval(float min, float max);
double tis_double_interval(double min, double max);

// Fill memory with abstract/unknown values
void tis_make_unknown(char *p, unsigned long len);

// Nondeterministic choice between two values
int tis_nondet(int a, int b);

// Nondeterministic choice between two pointers (useful for NULL testing)
static inline void *tis_nondet_ptr(void *a, void *b);
"""


def get_tis_builtin_reference() -> str:
    """Return condensed TIS builtin reference for prompts."""
    return TIS_BUILTIN_REFERENCE


DRIVER_GENERATION_TEMPLATE = """
You are an expert C programmer specializing in writing verification drivers for formal analysis using TrustInSoft Analyzer.

## Context

Function to test: {function_name}

### Source Files:
{context}

## Requirements

Write a comprehensive C11 verification driver for {function_name}. Cover all relevant edge cases and code paths. Go beyond minimal implementations while keeping the driver focused and minimal—do not add unnecessary abstractions, helper functions, or features beyond what's needed to verify the target function.

The goal is to mathematically verify the absence of undefined behaviors (UB) through abstract interpretation.
TrustInSoft Analyzer executes the code symbolically: given fully-defined C code, if no alarms are raised,
the code is guaranteed to behave predictably regardless of compiler or target platform.
By providing generalized inputs, you help verify that all possible execution paths within those ranges are UB-free.

### Driver Structure:
1. Header comment: `// TIS-Analyzer verification driver for function {function_name}. It has been generated by tischiron with model {model}.`
2. Include `<tis_builtin.h>`
3. Function declaration as `extern`
4. Driver function: `__tis_{function_name}_driver(void)`
5. Main function calling all driver functions in order

### TIS Builtin Functions:

A "generalized" value means a value within a specified range that represents all possible values in that range during analysis. For example, `tis_interval(0, 10)` represents any value in [0, 10].

Available functions from `<tis_builtin.h>`:
```c
{tis_builtin_reference}
```

### Object Creation:
- If constructor functions are provided in the context (e.g., `foo_new()`, `foo_create()`), use them. Declare them as `extern` in your driver
- When using constructors, use opaque forward declarations (`struct foo;`) instead of defining struct contents

<c_syntax_for_opaque_types>
When you forward-declare a struct type, C requires the `struct` keyword in all uses until a typedef is created. Since the driver uses forward declarations without typedefs, always include `struct` when referencing these types.

Example with `my_object`:
```c
// Forward declaration
struct my_object;

// Function declarations - use "struct my_object *"
extern struct my_object *my_object_new(int value);
extern void my_object_free(struct my_object *obj);

// Variables - use "struct my_object *"
struct my_object *obj = my_object_new(42);
```

Copy the exact function signatures from the "Required Extern Declarations" section in the context. These signatures have the correct types and return values. Adding functions not listed there may cause compilation errors due to mismatched signatures.
</c_syntax_for_opaque_types>

### Using Generalized Values:

When passing numeric arguments to functions, use the appropriate interval function instead of hardcoded values. This ensures the analyzer tests all possible values in a range.

Examples:
- Instead of `create_int(42)`, use `create_int(tis_interval(-1000, 1000))`
- Instead of `create_double(3.14)`, use `create_double(tis_double_interval(-1e6, 1e6))`
- Instead of `set_value(100)`, use `set_value(tis_interval(0, INT32_MAX))`
- For booleans: use `tis_interval(0, 1)` or `tis_nondet(0, 1)`

Over-approximation warning: When intervals are too wide, the analyzer may need to merge states, causing over-approximation. This can lead to:
- False alarms on unrealistic code paths (e.g., error handlers triggered by impossible values)
- State explosion slowing analysis or exhausting memory
- Imprecise results that are hard to interpret

Mitigation strategies:
- Use domain-appropriate ranges (e.g., for a percentage: `tis_interval(0, 100)`, not `tis_interval(INT32_MIN, INT32_MAX)`)
- Constrain inputs based on function preconditions or API contracts
- For complex algorithms (parsers, crypto), consider narrower ranges or multiple targeted drivers

### Guidelines:

Test NULL pointers using `tis_nondet_ptr(valid_ptr, NULL)` unless documentation indicates the pointer must be valid. Array lengths should use `#define` macros instead of `tis_interval` for sizes, as variable-length arrays complicate analysis. Ensure all strings are null-terminated and all struct fields are initialized before use.

Focus on exercising code paths rather than testing function effects—the goal is to reach all branches, not to verify return values. Use "generalized" instead of "random" in comments because "generalized" accurately describes abstract interpretation semantics, while "random" implies probabilistic testing.

### Header Includes:
- Include `<tis_builtin.h>` and standard C headers as needed (`<stddef.h>`, `<stdint.h>`, `<string.h>`, etc.)
- You may include project headers if they are provided in the context
- Alternatively, use forward declarations for types you don't need to access internals of

### Output Format:
Return your driver in a single ```c code block. If you need to explain critical decisions, use C comments within the code.
"""

REFINER_TEMPLATE = """
You are fixing a TIS-Analyzer verification driver that failed compilation.

## Current Driver Code:
```c
{current_code}
```

## Compilation Errors:
{errors}

## Common Fixes:

<fix_syntax_error_after_variable_name>
"syntax error... unexpected input after the variable name X": This means a forward-declared struct type is missing the `struct` keyword.

When you forward-declare `struct X;`, you must write `struct X *` everywhere, not just `X *`.

Fix by adding `struct` before the type name:
```c
// Wrong - causes "unexpected input after variable name my_object"
extern my_object *my_object_new(int i);
my_object *obj;

// Correct - use "struct my_object"
extern struct my_object *my_object_new(int i);
struct my_object *obj;
```
</fix_syntax_error_after_variable_name>

<fix_incompatible_declaration>
"Incompatible declaration for X: different type constructors": Your function declaration has the wrong return type or parameter types compared to the actual library.

Fix by checking what the real function returns. Common mistakes:
- A `*_put` or `*_free` function may return `int` (refcount), not `void`
- A `*_add` function may return `int` (success/error code), not `void`

Remove any function declarations you added that weren't in the original context, or correct their signatures to match the actual API.
</fix_incompatible_declaration>

- "incomplete type": Provide full struct definition with all fields, not just forward declaration
- "undeclared identifier": Add missing forward declaration
- "variable-sized object": Use #define macros for array sizes
- "unbound function tis_*": Include <tis_builtin.h>

## Header Rules:
Use only `<tis_builtin.h>` and standard C headers. For project types, use forward declarations (`struct X;`) rather than including project headers. The driver is compiled with the actual source files.

## Instructions:
Fix the compilation errors and return the complete corrected driver in a ```c block.

Iteration: {iteration}/{max_iterations}
"""


def format_context_from_contents(context_contents: List[Dict[str, str]]) -> str:
    """
    Format context files for prompt injection.

    Args:
        context_contents: List of dicts with 'name' and 'content' keys

    Returns:
        Formatted string with all context files
    """
    formatted = []
    for ctx in context_contents:
        name = ctx.get("name", "unknown")
        content = ctx.get("content", "")
        formatted.append(f"File: {name}\n```c\n{content}\n```")

    return "\n\n".join(formatted)


def format_include_paths(include_paths: List[str]) -> str:
    """Format include paths for prompt."""
    if not include_paths:
        return "(none specified)"
    return "\n".join(f"- {path}" for path in include_paths)


def build_generation_prompt(
    function_name: str,
    context_contents: List[Dict[str, str]],
    include_paths: List[str] = None,
    model: str = "unknown",
) -> str:
    """
    Build the driver generation prompt.

    Args:
        function_name: Name of the function to generate driver for
        context_contents: List of dicts with 'name' and 'content' keys
        include_paths: List of include paths from compilation database
        model: Model name used to generate the driver

    Returns:
        Formatted prompt string
    """
    context = format_context_from_contents(context_contents)

    return DRIVER_GENERATION_TEMPLATE.format(
        function_name=function_name,
        context=context,
        model=model,
        tis_builtin_reference=get_tis_builtin_reference(),
    )


def build_refiner_prompt(
    current_code: str, errors: list, iteration: int, max_iterations: int
) -> str:
    """Build the refinement prompt."""
    if errors:
        error_text = "\n".join(errors)
    else:
        error_text = (
            "Compilation failed but no specific error messages were captured. "
            "Common issues to check:\n"
            "- Incompatible type declarations between driver and source\n"
            "- Missing or incorrect struct definitions\n"
            "- Function signature mismatches\n"
            "- Missing #include directives"
        )
    return REFINER_TEMPLATE.format(
        current_code=current_code,
        errors=error_text,
        iteration=iteration,
        max_iterations=max_iterations,
    )


# TODO make a switch on a arbitrary tis_interval 0-10000,
# for each case of the switch exectute signle unit test (make a template). This allows "sandboxing" by branch.


#TODO rm tis_init_type


# TODO add stub section : 
### Stubs:
""" A stub is a simplified reimplementation of a function that produces sufficiently accurate behavior for analysis without the full implementation complexity.

When to create stubs:
- External dependencies (filesystem, network, hardware registers) that aren't available during analysis
- Functions with side effects that would complicate analysis (e.g., logging, I/O)
- Third-party library functions not included in the analysis scope

Stub guidelines:
- Return generalized values covering the expected output range: `int stub_read() {{ return tis_interval(-1, MAX_READ); }}`
- For functions that modify output parameters, use `tis_make_unknown()` to fill buffers with abstract values
- Preserve the function's contract: if the real function can return errors, the stub should too
- Declare stubs as regular functions (not `extern`) so they override the original during linking """